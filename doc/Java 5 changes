Eclipse... Software Update
New Remote Site: 
Name: Findbugs
URL: http://findbugs.cs.umd.edu/eclipse

Name: CheckStyle Eclipse Plug-in
URL: http://eclipse-cs.sourceforge.net/update

Class Hierarchy
---------------
WikiContext is the all-singing, all-dancing "request context" class in JSPWiki. It encapsulates the idea of "doing a wiki activity": viewing a page, editing a group, commenting, etc. In Stripes parlance, these are what you'd call "ActionBeans."

WikiContext was originally conceived to encompass everything and everything you might want to do to a wiki page. In JSPWiki 2.4 and higher, WikiContext got overloaded with lots of activities that have nothing to do with pages, like creating groups and registering. 

It has been clear for a while that WikiContext needed to split itself into multiple classes and interfaces. The most logical thing to do is make WikiContext the general class or interface actions that deal exclusively with pages. Therefore: WikiContext becomes an abstract subclass of AbstractActionBean. 

Note that because WikiContext becomes abstract, we need to change all of the direct instantiations of WikiContext. So, what I've done is created a WikiContext subclass (a Stripes ActionBean, in fact) called ViewActionBean that is for the "view page" context. 

The new class hierarchy for WikiContext and related types, for 3.0, looks like this:

    WikiActionBean extends ActionBean [Stripes]

    AbstractActionBean implements WikiActionBean
     |
     +--WikiContext extends AbstractActionBean
     |   |
     |   +--ViewActionBean extends WikiContext
     |   +--EditActionBean extends WikiContext
    ... ... ...
     +--GroupActionBean extends AbstractActionBean
     |
     +--UserPreferencesActionBean extends AbstractActionBean
    ...     

[NOTE: it would be nice if we could deprecate "WikiContext" in favor of, for example, "PageActionBean" to clearly denote that it's about page activities. Maybe PageActionBean becomes the interface, and we start coding to that...]

The new class structure means that techniques for creating WikiContexts will change. Old instantiations of WikiContext looked like this:

WikiContext dummyContext = new WikiContext( m_engine, m_context.getPage() );

WikiContext dummyContext = new WikiActionBean( m_engine, m_context.getPage() );

In 3.0, if you want to create a new ViewActionBean you can do it via the zero-arg constructor [WikiContext context = new ViewActionBean()] -- although you must immedidately also call setActionBeanContext() and set the ActionBeanContext's WikiEngine reference. It's much easier, instead, to call the factory method WikiActionBeanFactory.newActionBean( WikiPage page), which does it for you (see below).

Other significant changes to WikiContext:

- The setRequestContext() method disappears (it was only used in like 5 places anyway), because the WikiContext subclasses *are* the contexts. getReqeustContext() merely looks up a special JSPWiki class-level annotation that specifies the context. (For example: @WikiRequestContext("view"))

- WikiContext.getCommand() goes away, as do the other Command-related methods. Command interface is eliminated. It was a pretty dodgy idea to begin with.

- getLocale(). Not used in JSPs or core code. Because Stripes takes care of a lot of this, it's not needed.

- hasAccess()/requiredPermission(). This are handled by our own Stripes interceptor/controller (WikiInterceptor) in combination with event-level annotations. So these methods should absolutely be eliminated.

WikiActionBean Security
-----------------------
In 2.4, security permissions were added to WikiContexts. Each WikiContext could specify what Permission a user needed to access that context by causing the method requiredPermission() to return a value. This worked well, although it required each WikiContext type ("view","edit" etc.) to figure out a way to express the Permission through code. This, in part, was what let to the disaster that is the Command class.

In 3.0, Permissions are much more flexible because they are annotation-driven. Moreover, they are specified at the method level, NOT at the class (WikiContext) level. Because WikiContext (and its subclasses) implement ActionBean, this is another way of saying, "Permissions annotate methods that do things." For example, consider ViewActionBean, which is a WikiContext subclass that displays a wiki page. Its default event is the "view()" method, which simply forwards control to itself and causes the page to display. Here's the method signature:

    @DefaultHandler
    @HandlesEvent("view")
    @EventPermission(permissionClass=PagePermission.class, target="${page.qualifiedName}", actions=PagePermission.VIEW_ACTION)
    public Resolution view() { ... }

Note the @EventPermission annotation. It defines the Permission class and its target and actions. The "permissionClass" attribute tells use that the Permission class this method needs is "PagePermission". Note also the JSTL-style syntax in the target and actions attributes -- these allow JSTL-access to bean properties for the instantiated ViewActionBean. In this case, "page" is the bean attribute that returns the value of this ViewActionBean's getPage() method. The nested syntax "page.qualifiedName" is equivalent to getPage().getQualifiedName(). Neat, huh?

i18n
----
Switching to Stripes for URL building (via URLBuilder) causes UTF-8 strings to be created by the getURL methods:

So:
<a class="wikipage" href="/Wiki.jsp?page=%C4itiSy%F6%D6ljy%E4">ÄitiSyöÖljyä</a>

becomes:
<a class="wikipage" href="/Wiki.jsp?page=%C3%84itiSy%C3%B6%C3%96ljy%C3%A4">ÄitiSyöÖljyä</a>


Migration to Stripes tags:

stripes:form. must change accept-charset to acceptcharset

WikiTagBase extents StripesTagSupport in 3.0, not TagSupport. That means we needed to create a few methods that are in TagSupport but aren't in StripesTagSupport. Easily done...

Also, the method TagSupport.findAncestorWithClass which is used by TabTag needs to be replaced by StripesTagSupport.getParentTag (without need for classcast).


Thoughts on URLConstructor
--------------------------
http://tuckey.org/urlrewrite/manual/3.0/

Looks like we could rewrite everything!

For inbound requests: if UrlRewrite is the first servlet filter it will translate correctly coming in. Thus: /wiki/Page1 might forward to /wiki/Wiki.jsp?page=Page1. 

For outbound responses: UrlRewrite needs to be the last thing that manipulates the URL. For outbound URLs, you can generate a useful URL by calling HttpServletResponse.encodeURL(String), where the parameter is the URL you want to re-write. 

    --> Note: this means WikiServlet goes away (the destroy logic goes to WikiServletFilter for now)

Making things a little tricker: Stripes Resolutions also generate their own URLS. This is done by creating a new RedirectResolution(WikiActionBean), where the WikiActionBean is the "url" you want to redirect to. Add parameters as necessary. 

To tie all of this together:

Some classes currently call the URLConstructor directly. Mostly, this is WikiContext and WikiEngine (about 22 references in the JSPWiki core classes, plus 2 in the JSPs). However, most classes get their URLs by calling WikiContext.getViewURL(), getRedirectURL(), and getURL()/getURL() -- 73 references within the core, and 23 references in the templates. These probably should not be changed for compatibility's sake. However, we could easily cause these WikiContext/WikiEngine references to URLContructor instead to use Resolution.getURL + response.encodeURL().

Thus: to get a proper URL from inside a method that takes a WikiContext we'd do this: 

// Create a new resolution and add the page parameter to it
Resolution resolution = new RedirectResolution(ViewActionBean.class);
resolution.addParameter("page", page.getName();

// Get the response from the WikiContext (its superclass returns the ActionBeanContext, which has it)
HttpServletResponse response = context.getContext().getResponse();

// Now, encode the URL (passing it up the chain until it hits the UrlRewrite filter)
String url = response.encodeURL( resolution.getURL() );

A better example, this time with UrlBuilder:

            // Make Stripes URL
            String groupUrl = ViewGroupActionBean.class.getAnnotation(UrlBinding.class).value();
            UrlBuilder urlBuilder = new UrlBuilder(  groupUrl, true );
            urlBuilder.addParameter("group", name);
            String url = urlBuilder.toString();
            
            // Make re-written URL
            String rewriteUrl = context.getContext().getResponse().encodeURL( url );
            
            
--> Note: this means we need to replace WikiEngine.getURL() calls with equivalent calls to UrlBuilder + response.encodeUrl() 

WikiEngine.getURL goes away completely. Now, we need to get the ActionBeanContext in order to generate an URL.


ContentTemplates, JSPs, URLPatterns and RequestContexts
-------------------------------------------------------
In 2.4 we welded ContentTemplates, JSPs and RequestContexts together in the Command class. This helped unify some things, but it really doesn't fit in with Stripes all that well. Frankly, specifying a content template is really in the domain of JSP markup, and shouldn't be in classes. The URLPatterns are there because we need them for the URLConstructor. But if we delegate URL construction to Stripes and UrlRewrite, then we don't need this anymore. RequestContexts are still useful because we need to look up ActionBeans (e.g., WikiContexts) that way. We should still allow them, but deprecate them.

General behaviors need to change in the JSP layer so that instead of looking up a URL and then calling redirect directly, we need instead to obtain RedirectResolutions.

Stashing variables in PageContexts
----------------------------------
WikiTagBase chokes hard when it can't find a WikiContext associated with the the PageContext. That's because there's an expectation that the top-level JSP will stash the right context. In the new world WikiContexts are supplanted by ActionBeans. Do the page-specific tags need guaranteed access to a WikiContext? Hmm.... how can we stick one in there upstream? Do we name specific beans PAGE_BEAN, GROUP_BEAN, etc. or do push/pop operations

Contract ought to be: top-level JSP *guarantees* that it will inject a WikiActionBean, with a well-known name ACTIONBEAN ("wikiActionBean"), into request scope. WikiTagBase should first look for the well-known ActionBean, then iterate through the stored attributes and grab the first value it finds of type ActionBean. If an ActionBean can't be found, throw a WikiException. (Like what we do now.)

Thus: by convention, top-level JSPs MUST add a tag similar to this to the top of their pages if they want the bean recognized later by WikiTagBase:

<stripes:useActionBean beanclass="com.ecyrd.jspwiki.action.____ActionBean"/>

The first JSP to to use the useActionBean class will, by definition, cause the ACTIONBEAN request attribute to be set with this name binding. WikiTagBase's m_actionBean will obtain this value. 

Note: redefining m_context as m_actionBean (with type change to WikiActionBean) makes 32 out of 70 JSP tags fail to compile because they expect a getPage() method. We will need to supply guidance on how to migrate tags. 

In JSPs, the fact that the WikiActionBean for the page is bound as 'wikiActionBean' means that JSTL markup can access this parameter directly. It also means that we can *probably* get rid of the WikiContext.getContext() static method. In fact, we probably should. But for now, it's best to leave it but redefine the return type so that it's a WikiActionBean. That will break a few things.

Dead Code
---------
WikiEngine.getRedirectURL(). Not used anywhere in the new code, and only once in the old Wiki.jsp. Eliminated.

WikiEngine.createContext(). Better to use WikiActionBeanFactory.find...

WikiEngine.getSpecialPageReference(). Used exactly once, in NewBlogEntry.jsp. Eliminated.

WikiTagBase now guarantees that the protected field m_page will be set if it's a WikiContext This eliminates lots of classcasting.

Things I haven't solved yet
---------------------------
Stopwatch from Wiki.jsp
WatchDog from Wiki.jsp

API Changes
-----------
VariableManager.getValue method sigs widened to WikiActionBean (from WikiContext to WikiActionBean)

ContentTag's default content page is Beanclass name - "ActionBean" + "Content.jsp"

WikiSession/ActionBeanContext
-----------------------------
Stripes ActionBeanContext wraps the request/response objects and provides information about the servlet context. It is created anew for each request, I think. So it's not suitable for "merging" with WikiSession.

WikiContext getLocale(). Not used in JSPs or core code. Because Stripes takes care of a lot of this, it's not needed.

WikiContext hasAccess(). Really, this should be handled by the stripes interceptor/controller. So these methods should absolutely be eliminated.



 
WikiActionBean Contract
-----------------------
WikiActionBeans are the core action class in JSPWiki 3.0. All WikiActionBeans are expected to adhere to the following contract:
- must have a zero-argument constructor
- must set the ActionBeanContext immediately after instantiation (setContext)
- must set the associated ActionBeanContext's WikiEngine immediately after instantiation (setWikiEngine)

WikiActionBeans can be created in four ways:
1) Injection by UseActionBeanTag due to <stripes:useActionBean> tag in JSP. This is the preferred way because it can be done with little effort, and only requires single line at effort, and only requires single line at the top of a top-level JSP:

<stripes:useActionBean beanclass="com.ecyrd.jspwiki.action.____ActionBean"/>

Technically, the WikiActionBean is looked up by Stripes' configured ActionResolver (by default, the AnnotatedClassActionResolver); the bean itself is instantiated using its zero-argument constructor. Stripes guarantees that the following things happen after instantiation, as part of its ActionBeanResolution lifecycle stage:
- The WikiActionBean's setActionBeanContext() method is called (by AnnotatedClassActionResolver); this causes a reference to a new WikiActionBeanContext to be set in the WikiActionBean
- The WikiActionBeanContext's setServletContext() method is called (by UseActionBeanTag); this sets an internal reference to the WikiEngine
- The WikiActionBeanContext's setRequest/setResponse methods are called (by DefaultActionBeanContextFactory). This will also retrieve and set a reference to the user's WikiSession

Thus, when <stripes:useActionBean> is used in a JSP, the WikiActionBean in question is guaranteed to have a non-null, valid WikiActionBeanContext associated with it. This WikiActionBeanContext, in turn, is guaranteed to return non-null results for its getResponse/getRequest/getServletContext methods, as well as its getWikiEngine and getWikiSession methods.

2) Injection by DispatcherServlet due to POST/GET to /dispatcher, /action/* or *.action URLs. This method appears to be used, in particular, by generated Stripes form elements. It is rare that a user would actually specify one of these URLs directly.

As with the previous method, the WikiActionBean is looked up by Stripes' configured ActionResolver. The same guarantees apply: after resolution and instantiation, the WikiActionBean will have a non-null, valid WikiActionBeanContext, and that the WikiActionBeanContext will return non-null results for getResponse/getRequest/getServletContext/getWikiEngine/getWikiSession.

In addition to these activities, in cases 1) and 2), after the ActionBeanResolution stage completes, JSPWiki's custom WikiInterceptor executes. It will do two things:

- Stash the resolved WikiActionBean into the HTTP request's ACTIONBEAN attribute (see above)

- Check for proper access by calling the the bean's requiredPermission() method and checking that the user has that permission (null means "allowed"). If not, a RedirectResolution is returned that directs the user to the login page and appends all request parameters. (Note: we should make it check for authentication; if the user is already logged in, it should redirect to a "forbidden" page.

These two techniques are the preferred ways to create WikiActionBeans. There are two other, less preferred, ways:

3) WikiActionBeanFactory.newActionBean(HttpServletRequest,HttpServletResponse,Class<? extends WikiActionBean>).

In this case, JSPWiki does things a little differently than how Stripes does it, but the result is the same. Like Stripes, it will instantiate a new WikiActionBean and associate it with a new WikiActionBeanContext.

4) WikiActionBeanFactory.newActionBean( HttpServletRequest request, WikiPage page) and 
WikiActionBeanFactory.newActionBean( WikiPage page).

Both of these methods instantiate ViewActionBeans and associate a WikiActionContext with the bean. The WikiActionContext's setWikiEngine and setServletContext methods are called after instantiation. If an HttpServletRequest was supplied, it is associated with the WikiActionContext.

Thus, when the createContext() methods are used, the resulting ViewActionBean is guaranteed to have a non-null, valid WikiActionBeanContext associated with it. This WikiActionBeanContext, in turn, is guaranteed to return non-null results for its getServletContext/getWikiEngine methods. Its getRequest() method may or may not be null.

WikiTagBase
-----------
WikiTagBase changes slightly to support Stripes. Instead of extending import javax.servlet.jsp.tagext.TagSupport, it now extends StripesTagSupport. However, StripesTagSupport does not supply the methods setId/GetId. So, we've had to implement these.

WikiActionBeanFactory
---------------------
newActionBean()  This method performs a similar role to the &lt;stripes:useActionBean&gt; tag, in the sense that it will instantiate an arbitrary WikiActionBean class and, in the case of WikiContext subclasses, bind a WikiPage to it. However, it lacks some of the capabilities the JSP tag possesses. For example, although this method will correctly identity the page requested by the user (by inspecting request parameters), it will not do anything special if the page is a "special page." If special page resolution and redirection is required, use the &lt;stripes:useActionBean&gt; JSP tag instead.


Eclipse Tools Notes
-------------------
TestEngine: Because of its use of Stripes mock objects, TestEngine needs to be able to find the various implementations provided in JSPWiki. Therefore, it is extremely sensitive to changes in the build path. In particular, the mock servlet filter used by TestEngine hard-wires in the relative location build for finding ActionBeans. This is the directory (relative to the project root) that the Ant build scripts use for placing generated Java class files. The Eclipse project configuration must configure itself the same way. To run unit tests in Eclipse, the build directory absolutely must place generated class files in this directory, rather than the Eclipse default of classes. If unit tests do not run in Eclipse for some reason, this is the likeliest culprit.
Use JVM args -Xmx1024m

URL Rewriting
-------------
http://tuckey.org/urlrewrite/manual/3.0/

Bugs Bugs Bugs
--------------
JSPWikiMarkupParserTest.testAttachmentLink

Expected
This should be an <a class="attachment" href="/attach/Test/TestAtt.txt">attachment link</a><a href="/PageInfo.jsp?page=Test/TestAtt.txt"><img src="/images/attachment_small.png" border="0" alt="(info)" /></a>

Actual
This should be an <a class="attachment" href="/attach/?page=Test/TestAtt.txt">attachment link</a><a href="/PageInfo.jsp?page=Test/TestAtt.txt"><img src="/None.jsp?page=images/attachment_small.png" border="0" alt="(info)" /></a>

Solution: hacked WikiConext so that getUrl() special-cases the AttachActionBean and NoneActionBean output

UndefinedPagesPluginTest.testSimpleUndefined

Expected
<a class="createpage" href="/Edit.jsp?page=Foobar%202" title="Create &quot;Foobar 2&quot;">Foobar 2</a><br />

Actual
<a class="createpage" href="/Edit.jsp?page=Foobar%202" title="Create &quot;Foobar 2&quot;">Foobar 2</a><br /><a class="createpage" href="/Edit.jsp?page=Page1000" title="Create &quot;Page1000&quot;">Page 1000</a><br /><a class="createpage" href="/Edit.jsp?page=Page1001" title="Create &quot;Page1001&quot;">Page 1001</a><br /><a class="createpage" href="/Edit.jsp?page=Page1002" title="Create &quot;Page1002&quot;">Page 1002</a><br /><a class="createpage" href="/Edit.jsp?page=Page1003" title="Create &quot;Page1003&quot;">Page 1003</a><br />

Testing issues
--------------
Both tests needed to be changed because Stripes encodes in UTF-8. 

JSPWikiMarkupParserTest.testCCLinkWithScandics()
        Old value of 'page': %C4itiSy%F6%D6ljy%E4
        New value: %C3%84itiSy%C3%B6%C3%96ljy%C3%A4

JSPWikiMarkupParserTest.testScandicPagename1()
        Old value of 'page': %C5%E4Test
        New value: %C3%85%C3%A4Test

GroupsTest:
Discovered Groups plugin has this line in it:

String rewriteUrl = context.getContext().getResponse().encodeURL( url );

...but the test ran without being in a MockServletContext. Thus, its parent WikiActionBeanContext had no associated response! Plugin test should *always* test inside a mock object.

Also, in TestEngine I had to override all of the getHTML methods so that the manufactured WikiContext had properly injected requests and responses.

GroupsPlugin right now does not generate Groups.jsp links, but Group.action links. Maybe it should generate .jsp links?


JSP Tier changes
----------------
All of the non-top-level JSPs that shouldn't be directly instantiated are moved to /WEB-INF/jsp/layout.

Some changes:
JSPs don't need this any more:  <fmt:setBundle basename="templates.default"/>
...because we set a context parameter in web.xml.

Scriptlet code in JSPs that needs to obtain a reference to the WikiEngine can simply use ${wikiEngine}.

Good practice: whenever useActionBean is used in a JSP, author should always set the 'var' attribute so that downstream JSPs can use the variables.

WikiInterceptor will attempt to set the current WikiActionBean and WikiPage into page scope. These are available as ${wikiPage}. It will also set ${wikiEngine} and ${wikiSession}. These are set in request scope.

Migration: this means...
<%
  WikiContext c = WikiContext.findContext(pageContext);
  WikiPage wikipage = c.getPage();
%>
...can simply be replaced by ${wikiPage}.



BUG: LinkTag didn't always init its m_containedParameters map. (So, I fixed it...)

2.6 commonheader.jsp
	'JsonUrl' : '<%=  WikiContext.findContext(pageContext).getURL( WikiContext.NONE, "JSON-RPC" ) %>'
3.0
	'JsonUrl' : 'JSON-RPC'

JSP Locale Support
Because Stripes automatically sets the locale, there is no need to use methods like this:
LocaleSupport.getLocalizedMessage(pageContext, "attach.tab")

Instead, you can simply use:
<fmt:message key="attach.tab"/>


Stripes layout system
---------------------
This is replaced:
      <wiki:Content/>
by


Scriptlet code (e.g., PageTab.jsp)

	WikiContext c = WikiContext.findContext( pageContext );

Replaced by

	WikiContext c = (WikiContext)WikiInterceptor.findActionBean();
	
Wiki:Tab needs to be able to evaluate attribute contents... now it doesn't...


Things that don't work
----------------------
RSSGenerator, probably...
WikiJSPFilter should not have the lookup bean method...

The Stripes version has a qualfied name method in WikiPage, Group etc. Did these go away in 2.6?
FeedDiscoveryTag probably needs a total re-compare.